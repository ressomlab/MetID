# tune parameters
d <- ncol(Data)
loglik <- lapply(seq_along(rho), function(i) {
vapply(seq_len(n_fold), function(j) {
# segement your data by fold using the which() function
testIndexes <- which(folds == j, arr.ind = TRUE)
testData <- Data[testIndexes, ]
trainData <- Data[-testIndexes, ]
# use test and train data partitions however you desire...
cov <- var(trainData) # compute the covariance matrix
pre<- glasso(cov, rho = rho[i])
loglik_ave(testData, pre$wi)
}, numeric(1))
loglik_cv <- vapply(loglik, mean, numeric(1))
loglik_rho <- vapply(loglik, function(x) sd(x) / sqrt(n_fold), numeric(1))
plot(rho, loglik_cv, xlab = expression(lambda), ylab = "Error")
lines(rho, loglik_cv)
error <- list("log.cv" = loglik_cv, "log.rho" = loglik_rho)
return(error)
}
}
## Draw error curve
choose_rho <- function(data, n_fold, rho) {
# randomly shuffle the data
Data <- data[sample(nrow(data)), ]
# create n_fold equally size folds
folds <- cut(seq(1, nrow(Data)), breaks = n_fold, labels = FALSE)
# tune parameters
d <- ncol(Data)
loglik <- lapply(seq_along(rho), function(i) {
vapply(seq_len(n_fold), function(j) {
# segement your data by fold using the which() function
testIndexes <- which(folds == j, arr.ind = TRUE)
testData <- Data[testIndexes, ]
trainData <- Data[-testIndexes, ]
# use test and train data partitions however you desire...
cov <- var(trainData) # compute the covariance matrix
pre<- glasso(cov, rho = rho[i])
loglik_ave(testData, pre$wi)
}, numeric(1))
loglik_cv <- vapply(loglik, mean, numeric(1))
loglik_rho <- vapply(loglik, function(x) sd(x) / sqrt(n_fold), numeric(1))
plot(rho, loglik_cv, xlab = expression(lambda), ylab = "Error")
lines(rho, loglik_cv)
error <- list("log.cv" = loglik_cv, "log.rho" = loglik_rho)
return(error)
})}
## Draw error curve
choose_rho <- function(data, n_fold, rho) {
# randomly shuffle the data
Data <- data[sample(nrow(data)), ]
# create n_fold equally size folds
folds <- cut(seq(1, nrow(Data)), breaks = n_fold, labels = FALSE)
# tune parameters
d <- ncol(Data)
loglik <- lapply(seq_along(rho), function(i) {
vapply(seq_len(n_fold), function(j) {
# segement your data by fold using the which() function
testIndexes <- which(folds == j, arr.ind = TRUE)
testData <- Data[testIndexes, ]
trainData <- Data[-testIndexes, ]
# use test and train data partitions however you desire...
cov <- var(trainData) # compute the covariance matrix
pre<- glasso(cov, rho = rho[i])
loglik_ave(testData, pre$wi)
}, numeric(1))})
loglik_cv <- vapply(loglik, mean, numeric(1))
loglik_rho <- vapply(loglik, function(x) sd(x) / sqrt(n_fold), numeric(1))
plot(rho, loglik_cv, xlab = expression(lambda), ylab = "Error")
lines(rho, loglik_cv)
error <- list("log.cv" = loglik_cv, "log.rho" = loglik_rho)
return(error)
}
library(stringr)
install.packages("stringr")
stringr
ss='ddd xxx hhh'
get_first <- function(id){
# This function gets the first id if there are multiple ids.
for (i in 1:length(id)){
if (id[i]==''){
id[i] <- ''
} else {
temp <- strsplit(id[i],' ')[[1]]
id[i] <- temp[1]
}
}
return(id)
}
get_first(ss)
get_first('')
word(ss,1)
library(stringr)
library("stringr", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
library("stringi", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
remove.packages('stringi', lib)
remove.packages('stringi')
remove.packages('stringi',â€˜/Library/Frameworks/R.framework/Versions/3.4/Resources/libraryâ€™)
remove.packages('stringi',lib='/Library/Frameworks/R.framework/Versions/3.4/Resources/library')
install.packages("stringi")
library("stringi", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
library("stringr", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
ss
word(ss,1)
word('',1)
n <- length(id)
response <- rep(NA,n)
for (i in 1:n){
if (!is.na(id[i])){
if (!id[i] %in% InchiKey$CID){
response[i] <- as.character(id[i])
}
else{
response[i] <- substr(InchiKey$InchiKey[which(InchiKey$CID %in% id[i])],1,14)
}
}
}
get_inchikey <- function(id){
# This function gets the fist 14 charactors of InchiKey from PubChem database.
n <- length(id)
response <- rep(NA,n)
for (i in 1:n){
if (!is.na(id[i])){
if (!id[i] %in% InchiKey$CID){
response[i] <- as.character(id[i])
}
else{
response[i] <- substr(InchiKey$InchiKey[which(InchiKey$CID %in% id[i])],1,14)
}
}
}
return(response)
}
load("~/Documents/MetID/data/demo1.RData")
load("~/Documents/MetID/data/demo2.RData")
load("~/Documents/MetID/data/InchiKey.rda")
View(InchiKey)
get_inchikey <- function(id){
# This function gets the fist 14 charactors of InchiKey from PubChem database.
n <- length(id)
response <- rep(NA,n)
for (i in 1:n){
if (!is.na(id[i])){
if (!id[i] %in% InchiKey$CID){
response[i] <- as.character(id[i])
}
else{
response[i] <- substr(InchiKey$InchiKey[which(InchiKey$CID %in% id[i])],1,14)
}
}
}
return(response)
}
View(demo1)
View(demo2)
View(demo2)
View(demo1)
cid <- demo2$PubChem.CID
cid <- format_id(cid, na = na, sep = sep)
cid <- as.numeric(word(cid,1))
inchikey <- get_inchikey(cid)
inchikey
xxx1<-'BRMWTNUJHUMWMS-LURJTMIESA-N'
strsplit(xxx1,split='-')
strsplit(xxx1,split='-')[1]
strsplit(xxx1,split='-')[[1]]
strsplit(xxx1,split='-')[[1]][1]
InchiKey$InchiKey[which(InchiKey$CID) =='92105']
InchiKey$InchiKey[(InchiKey$CID) =='92105']
str(999)
InchiKey$CID[1]
InchiKey$CID[1] == "92105"
InchiKey$CID[1] == 92105
get_ik<- function(ids){
response<-lapply(ids, function(i) {
InchiKey$InchiKey[(InchiKey$CID) == i]
return(response)
}
}
)
get_ik<- function(ids){
response<-lapply(ids, function(i) {
InchiKey$InchiKey[(InchiKey$CID) == i]
return(response)
}
)}
get_ik(cid)
get_ik<- function(ids){
response<-lapply(ids, function(i) {
InchiKey$InchiKey[(InchiKey$CID) == i]
}
return(response)
)}
get_ik<- function(ids){
response<-lapply(ids, function(i) {
InchiKey$InchiKey[(InchiKey$CID) == i]})
return(response)}
get_ik(cid)
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
InchiKey$InchiKey[(InchiKey$CID) == i]})
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-sapply(ids, function(i) {
InchiKey$InchiKey[(InchiKey$CID) == i]})
return(response)}
xc<-get_ik(cid)
xc
get_ik<- function(ids){
response<-vapply(ids, function(i) {
InchiKey$InchiKey[(InchiKey$CID) == i]})
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
InchiKey$InchiKey[(InchiKey$CID) == i]},character))
return(response)}
get_ik<- function(ids){
response<-vapply(ids, function(i) {
InchiKey$InchiKey[(InchiKey$CID) == i]},character)
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
InchiKey$InchiKey[(InchiKey$CID) == i]},character(14))
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-sapply(ids, function(i) {
substr(InchiKey$InchiKey[(InchiKey$CID) == i],1,14)
})
return(response)}
xc<-get_ik(cid)
xc
xc[1]
xc[[1]]
a<xc[[1]]
a<-xc[[1]]
get_ik<- function(ids){
response<-sapply(ids, function(i) {
as.character(substr(InchiKey$InchiKey[(InchiKey$CID) == i],1,14))
},character(14))
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-sapply(ids, function(i) {
as.character(substr(InchiKey$InchiKey[(InchiKey$CID) == i],1,14))
})
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
as.character(substr(InchiKey$InchiKey[(InchiKey$CID) == i],1,14))
} FUN.VALUE = character(1))
return(response)}
get_ik<- function(ids){
response<-vapply(ids, function(i) {
as.character(substr(InchiKey$InchiKey[(InchiKey$CID) == i],1,14))
}, FUN.VALUE = character(1))
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID) == i],1,14))
}, FUN.VALUE = character(1))
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID == i)],1,14))
}, FUN.VALUE = character(1))
return(response)}
xc<-get_ik(cid)
cid
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID == '7294')],1,14))
get_ik<- function(ids){
response<-vapply(ids, function(i) {
if(is.na(i) || !i %in% InchiKey$CID){
as.character('N')
}
else {
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID == i)],1,14))}
}, FUN.VALUE = character(1))
return(response)}
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID == '7294')],1,14))
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
if(is.na(i) || !i %in% InchiKey$CID){
NA
}
else {
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID == i)],1,14))}
}, FUN.VALUE = character(1))
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
if(is.na(i) || !i %in% InchiKey$CID){
'NA'
}
else {
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID == i)],1,14))}
}, FUN.VALUE = character(1))
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
if(is.na(i) || !i %in% InchiKey$CID){
return(NA)
}
else {
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID == i)],1,14))}
}, FUN.VALUE = character(1))
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
if(is.na(i) || !i %in% InchiKey$CID){
return(NA)
}
else {
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID == i)],1,14))}
}, FUN.VALUE = c(character(1),logical(1)))
return(response)}
xc<-get_ik(cid)
get_ik<- function(ids){
response<-vapply(ids, function(i) {
if(is.na(i) || !i %in% InchiKey$CID){
as.character(NA)
}
else {
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID == i)],1,14))}
}, FUN.VALUE = character(1))
return(response)}
xc<-get_ik(cid)
all.equal(xc,inchikey)
inchikey
xc
get_ik<- function(ids){
response<-vapply(ids, function(i) {
if(is.na(i) || !i %in% InchiKey$CID){
as.character(NA)
}
else {
as.character(substr(InchiKey$InchiKey[which(InchiKey$CID == i)],1,14))}
}, FUN.VALUE = character(1))
return(response)}
xc<-get_ik(cid)
all.equal(xc,inchikey)
as.matrix(xc)
aa<-as.matrix(xc)
bb<-as.matrix(inchikey)
View(aa)
View(bb)
tempf<-function(a=100){
print(a)
}
tempf()
tempf(a=500)
remove.packages(yaml)
remove.packages('yaml')
install.packages('yaml')
getwd()
setwd("/Users/zhenzhi/Documents/MetID")
#' Get scores for metabolite putative IDs by LC-MS .
#'
#' @param filename the name of the file which the data are to be read from. Its type should be chosen
#'             in 'type' parameter. Also, it should have columns named exactly 'metid' (IDs for peaks),
#'             'query_m.z' (query mass of peaks), 'exact_m.z' (exact mass of putative IDs),
#'             'kegg_id' (IDs of putative IDs from KEGG Database), 'pubchem_cid' (CIDs of putative IDs
#'             from PubChem Database). Otherwise, this function would not work.
#' @param type string indicating the type of the file. It can be a 'data.frame' which is already loaded
#'             into R, or some other specified types like a csv file.
#' @param na a character vector of strings which are to be interpreted as NA values.
#' @param sep a character value which seperates multiple IDs in kegg_id or pubchem_cid field, if there
#'            are multiple IDs.
#' @param mode string indicating the mode of metabolites. It can be positive mode (POS) or negative mode
#'             (NEG).
#' @param Size an integer which indicates sample size in Gibbs sampling.
#' @param delta a hyper-parameter representing the mean value of mass ratio.
#' @param gamma_mass a hyper-parameter representing the accuracy of mass measurement.
#' @param interations, ask user to input number of interations,default 500
#' @return A dataframe which contains input data together with a
#'         column of scores in the end. In the
#'         score column, if the row contains NA values or does not has a PubChem cid, the score would be
#'         '-', which stands for missing value. Otherwise, each score would be from 0 to 1.
#' @examples
#' ## check if colnames of dataset meet requirement
#' names(demo1)
#' ## change colnames
#' colnames(demo1) <- c('query_m.z','name','formula','exact_m.z','pubchem_cid','kegg_id')
#' ## get scores
#' out <- get_scores_for_LC_MS(demo1, type = 'data.frame', na='-', mode='POS')
#'
#' @export
#' @import ChemmineR
#' @importFrom stringr str_replace_all str_replace str_trim
#' @importFrom igraph graph_from_data_frame as_adjacency_matrix
#' @importFrom Matrix Matrix t
#' @importFrom stats dnorm rmultinom
#' @importFrom utils data read.csv read.table write.csv
#' @import devtools
get_scores_for_LC_MS <- function(filename, type = c('data.frame','csv','txt'), na = 'NA', sep = ';',
mode = c('POS','NEG'), Size=2000, delta=1, gamma_mass=10,iterations=500){
## Preprocess data
list_from_get_cleaned <- get_cleaned(filename, type = type, na = na, sep = sep)
df <- list_from_get_cleaned$df
mass <- list_from_get_cleaned$mass
ID <- list_from_get_cleaned$ID
## Build identification network
message("Start building network: it may take several minutes......")
Wk <- get_kegg_network(ID$kid)
Wt <- get_tani_network(ID$cid)
Wt[Wt>=0.7] <- 1
Wt[Wt<0.7] <- 0
W <- pmax(Wt,Wk)
## Gibbs sampling
# adjust mass according to mode
proto_mass = 1.00727646677
if (mode=='POS'){
qmass<-mass$qmass-proto_mass
} else if (mode=='NEG'){
qmass<-mass$qmass+proto_mass
}
# initialize Z
m <- dim(mass)[1]
c <- dim(ID)[1]
Z <- Matrix::Matrix(1,nrow=c,ncol=m,sparse=TRUE)
# I: binary matrix of identification~mass
I <- Matrix::Matrix(0,nrow=c,ncol=m)
for (i in 1:m){
I[which(ID$metid==mass$metid[i]),i] <- 1
}
# load m.z data
X <- matrix(qmass,nrow=1)
Y <- as.matrix(as.numeric(ID$emass))
# Gibbs Samplings -- burn-in
message('Start getting random samples: it may take several minutes......')
for (s in 1:iterations){
beta_temp <- as.vector(W%*%Z%*%Matrix(1,ncol=1,nrow=m,sparse=TRUE))
beta <- Matrix::Matrix(beta_temp,ncol=m,nrow=c,sparse=TRUE)-W%*%Z
beta_sum <- Matrix::Matrix(apply(beta,1,sum),ncol=m,nrow=c,sparse=TRUE)
prior <- (delta+beta)/(c*delta+beta_sum)
post <- (dnorm((1/Y)%*%X,delta,gamma_mass/3*10^(-6))*prior)*I
post <- t(t(post)/apply(post,2,sum))
Z <- Matrix::Matrix(apply(post,2,function(x){rmultinom(1,1,x)}),sparse=TRUE)
}
# Gibbs Samplings
prob <- Matrix::Matrix(0,nrow=c,ncol=m,sparse=TRUE)
for (s in 1:(Size-iterations)){
beta_temp <- as.vector(W%*%Z%*%Matrix(1,ncol=1,nrow=m,sparse=TRUE))
beta <- Matrix(beta_temp,ncol=m,nrow=c,sparse=TRUE)-W%*%Z
beta_sum <- Matrix::Matrix(apply(beta,1,sum),ncol=m,nrow=c,sparse=TRUE)
prior <- (delta+beta)/(c*delta+beta_sum)
post <- (dnorm((1/Y)%*%X,delta,gamma_mass/3*10^(-6))*prior)*I
post <- t(t(post)/apply(post,2,sum))
Z <- Matrix::Matrix(apply(post,2,function(x){rmultinom(1,1,x)}),sparse=TRUE)
prob <- Z+prob
}
prob <- prob/(Size-iterations)
## add score column to the original file
message('Start writing scores......')
index_empty <- list_from_get_cleaned$index_na
df_dup <- list_from_get_cleaned$clean_data
df$score <- rep(0,dim(df)[1])
df$score[index_empty] <- '-'
for (i in 1:m){
subdf <- df_dup[df_dup$metid==mass$metid[i],]
inchikeys <- subdf[!duplicated(subdf$inchikey),]$inchikey
p <- prob[,which(mass$metid==mass$metid[i])]
p <- p[p!=0]
for (j in 1:length(inchikeys)){
ind <- as.numeric(rownames(subdf[subdf$inchikey==inchikeys[j],]))
df$score[ind] <- p[j]
}
}
df$score[is.na(df$score)] <- 0
message('Completed!')
write.csv(df,file = 'scores.csv')
return(df)
}
remove.packages('htmltools')
install.packages('htmltools')
remove.packages('Rcpp')
install.packages('Rcpp')
remove.packages("backports")
install.packages("backports")
select_sig(x = Met_GU, class_label = Met_Group_GU, id = Met_name_GU, partial = FALSE)
load('Documents/INDEED/data/Met_Group_GU.rda')
load('Documents/INDEED/data/Met_GU.rda')
load('Documents/INDEED/data/Met_name_GU.rda')
load('Documents/INDEED/data/pvalue_M_GU.rda')
load('~Documents/INDEED/data/Met_Group_GU.rda')
load('~Documents/INDEED/data/Met_GU.rda')
load('~Documents/INDEED/data/Met_name_GU.rda')
load('~Documents/INDEED/data/pvalue_M_GU.rda')
load('~Documents/INDEED/data/Met_Group_GU.rda')
load('~Documents/INDEED/data/Met_GU.rda')
load('~Documents/INDEED/data/Met_name_GU.rda')
load('~Documents/INDEED/data/pvalue_M_GU.rda')
load('data/Met_Group_GU.rda')
load('data/Met_GU.rda')
load('data/Met_name_GU.rda')
load('data/pvalue_M_GU.rda')
pwd
getwd()
load("data/demo1.RData")
View(demo1)
get_scores_for_LC_MS(demo1)
